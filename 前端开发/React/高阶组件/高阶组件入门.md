# ä»€ä¹ˆæ˜¯é«˜é˜¶ç»„ä»¶
é«˜é˜¶ç»„ä»¶ï¼ˆHOCï¼‰higher-order function,  æ˜¯ React ä¸­ç”¨äºå¤ç”¨ç»„ä»¶é€»è¾‘çš„ä¸€ç§é«˜çº§æŠ€å·§ã€‚HOC è‡ªèº«ä¸æ˜¯ React API çš„ä¸€éƒ¨åˆ†ï¼Œå®ƒæ˜¯ä¸€ç§åŸºäº React çš„ç»„åˆç‰¹æ€§è€Œå½¢æˆçš„è®¾è®¡æ¨¡å¼ã€‚

å…·ä½“è€Œè¨€ï¼Œ**é«˜é˜¶ç»„ä»¶æ˜¯å‚æ•°ä¸ºç»„ä»¶ï¼Œè¿”å›å€¼ä¸ºæ–°ç»„ä»¶çš„å‡½æ•°ã€‚**

```tsx
const HoC = Component => EnhancedComponent
```

```tsx
const withClassName = Component => props => (
  <Component {...props} className="my-class" />
)
```

```ad-tip
In the React community, it is very common to have the prefix **with** for HOCs.
```

ç»„ä»¶æ˜¯å°† props è½¬æ¢ä¸º UIï¼Œè€Œé«˜é˜¶ç»„ä»¶æ˜¯å°†ç»„ä»¶è½¬æ¢ä¸ºå¦ä¸€ä¸ªç»„ä»¶ã€‚

HOC ä¸ä¼šä¿®æ”¹ä¼ å…¥çš„ç»„ä»¶ï¼Œä¹Ÿä¸ä¼šä½¿ç”¨ç»§æ‰¿æ¥å¤åˆ¶å…¶è¡Œä¸ºã€‚ç›¸åï¼ŒHOC é€šè¿‡å°†ç»„ä»¶_åŒ…è£…_åœ¨å®¹å™¨ç»„ä»¶ä¸­æ¥_ç»„æˆ_æ–°ç»„ä»¶ã€‚HOC æ˜¯çº¯å‡½æ•°ï¼Œæ²¡æœ‰å‰¯ä½œç”¨ã€‚

HOC ä¸åº”è¯¥ä¿®æ”¹ä¼ å…¥ç»„ä»¶ï¼Œè€Œåº”è¯¥ä½¿ç”¨ç»„åˆçš„æ–¹å¼ï¼Œé€šè¿‡å°†ç»„ä»¶åŒ…è£…åœ¨å®¹å™¨ç»„ä»¶ä¸­å®ç°åŠŸèƒ½ã€‚
why HOCs usually **spread the props** `{...props}` they receive on the component is because they tend to be transparent and only add the new behavior.

ä¸‹é¢ğŸ‘‡ğŸ» æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªç¤ºä¾‹ï¼š

```ad-example

<iframe src="https://codesandbox.io/s/vigilant-phoebe-lli8mk" allow="fullscreen" allowfullscreen="" style="height: 100%; width: 100%; aspect-ratio: 16 / 9;"></iframe>


ä»£ç é‡Œå®ç°äº†ä¸€ä¸ª withInnerWidth é«˜é˜¶ç»„ä»¶ï¼Œå®ƒå¯ä»¥ä¼ é€’ç»™è¢«åŒ…è£¹çš„ç»„ä»¶ï¼Œç»„ä»¶å®½åº¦çš„å‚æ•°ã€‚
å¯ä»¥çœ‹åˆ°éšç€å®½åº¦çš„å˜åŒ–ï¼Œä¼ å…¥è¿›å»çš„ innerWidth å‚æ•°çš„å€¼ï¼Œéšä¹‹æ”¹å˜ã€‚

~~~tsx
import { useState, useEffect } from "react";

const withInnerWidth = (Component) => (props) => {
  const [innerWidth, setInnerWidth] = useState(window.innerWidth);

  const handleResize = () => {
    setInnerWidth(window.innerWidth);
  };

  useEffect(() => {
    window.addEventListener("resize", handleResize);

    return () => {
      window.removeEventListener("resize", handleResize);
    };
  }, []);

  return <Component {...props} innerWidth={innerWidth} />;
};

const MyComponent = ({ innerWidth }) => {
  return <div>Inner Width: {innerWidth}</div>;
};

const MyComponentWithInnerWidth = withInnerWidth(MyComponent);

export default function App() {
  return (
    <div className="App">
      <MyComponentWithInnerWidth />
    </div>
  );
}
~~~
```

# ç”¨ React Hook æ”¹å†™
[[React Hook å…¥é—¨]]

```ad-tip
The new React Hooks can easily replace an HOC by creating custom Hooks.
```

è®©æˆ‘ä»¬ç”¨ Hook å»æ”¹å†™ä¸Šé¢çš„ HOC å‡½æ•°

[Hook Rewrite Hoc Example - CodeSandbox](https://codesandbox.io/s/jovial-vaughan-b82ixy)

```tsx
import { useState, useEffect } from "react";

function useInnerWidth() {
  const [innerWidth, setInnerWidth] = useState(window.innerWidth);

  const handleResize = () => {
    setInnerWidth(window.innerWidth);
  };

  useEffect(() => {
    window.addEventListener("resize", handleResize);

    return () => {
      window.removeEventListener("resize", handleResize);
    };
  }, []);

  return innerWidth;
}

const MyComponent = () => {
  const innerWidth = useInnerWidth();
  return <div>Inner Width (Hook): {innerWidth}</div>;
};

export default function App() {
  return (
    <div className="App">
      <MyComponent />
    </div>
  );
}

```

# æ³¨æ„äº‹é¡¹

## ä¸è¦åœ¨ render æ–¹æ³•ä¸­ä½¿ç”¨ HOC
React çš„ diff ç®—æ³•ï¼ˆç§°ä¸º[åè°ƒ](https://zh-hans.reactjs.org/docs/reconciliation.html)ï¼‰ä½¿ç”¨ç»„ä»¶æ ‡è¯†æ¥ç¡®å®šå®ƒæ˜¯åº”è¯¥æ›´æ–°ç°æœ‰å­æ ‘è¿˜æ˜¯å°†å…¶ä¸¢å¼ƒå¹¶æŒ‚è½½æ–°å­æ ‘ã€‚ å¦‚æœä»Â `render`Â è¿”å›çš„ç»„ä»¶ä¸å‰ä¸€ä¸ªæ¸²æŸ“ä¸­çš„ç»„ä»¶ç›¸åŒï¼ˆ`===`ï¼‰ï¼Œåˆ™ React é€šè¿‡å°†å­æ ‘ä¸æ–°å­æ ‘è¿›è¡ŒåŒºåˆ†æ¥é€’å½’æ›´æ–°å­æ ‘ã€‚ å¦‚æœå®ƒä»¬ä¸ç›¸ç­‰ï¼Œåˆ™å®Œå…¨å¸è½½å‰ä¸€ä¸ªå­æ ‘ã€‚

é€šå¸¸ï¼Œä½ ä¸éœ€è¦è€ƒè™‘è¿™ç‚¹ã€‚ä½†å¯¹ HOC æ¥è¯´è¿™ä¸€ç‚¹å¾ˆé‡è¦ï¼Œå› ä¸ºè¿™ä»£è¡¨ç€ä½ ä¸åº”åœ¨ç»„ä»¶çš„ render æ–¹æ³•ä¸­å¯¹ä¸€ä¸ªç»„ä»¶åº”ç”¨ HOCï¼š

```tsx
render() {
  // æ¯æ¬¡è°ƒç”¨ render å‡½æ•°éƒ½ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„ EnhancedComponent
  // EnhancedComponent1 !== EnhancedComponent2
  const EnhancedComponent = enhance(MyComponent);
  // è¿™å°†å¯¼è‡´å­æ ‘æ¯æ¬¡æ¸²æŸ“éƒ½ä¼šè¿›è¡Œå¸è½½ï¼Œå’Œé‡æ–°æŒ‚è½½çš„æ“ä½œï¼
  return <EnhancedComponent />;
}
```

è¿™ä¸ä»…ä»…æ˜¯æ€§èƒ½é—®é¢˜ - é‡æ–°æŒ‚è½½ç»„ä»¶ä¼šå¯¼è‡´è¯¥ç»„ä»¶åŠå…¶æ‰€æœ‰å­ç»„ä»¶çš„çŠ¶æ€ä¸¢å¤±ã€‚
å¦‚æœåœ¨ç»„ä»¶ä¹‹å¤–åˆ›å»º HOCï¼Œè¿™æ ·ä¸€æ¥ç»„ä»¶åªä¼šåˆ›å»ºä¸€æ¬¡ã€‚å› æ­¤ï¼Œæ¯æ¬¡ render æ—¶éƒ½ä¼šæ˜¯åŒä¸€ä¸ªç»„ä»¶ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œè¿™è·Ÿä½ çš„é¢„æœŸè¡¨ç°æ˜¯ä¸€è‡´çš„ã€‚

## åŠ¡å¿…å¤åˆ¶é™æ€æ–¹æ³•

æœ‰æ—¶åœ¨ React ç»„ä»¶ä¸Šå®šä¹‰é™æ€æ–¹æ³•å¾ˆæœ‰ç”¨ã€‚
ä½†æ˜¯ï¼Œå½“ä½ å°† HOC åº”ç”¨äºç»„ä»¶æ—¶ï¼ŒåŸå§‹ç»„ä»¶å°†ä½¿ç”¨å®¹å™¨ç»„ä»¶è¿›è¡ŒåŒ…è£…ã€‚è¿™æ„å‘³ç€æ–°ç»„ä»¶æ²¡æœ‰åŸå§‹ç»„ä»¶çš„ä»»ä½•é™æ€æ–¹æ³•ã€‚

```tsx
// å®šä¹‰é™æ€å‡½æ•°
WrappedComponent.staticMethod = function() {/*...*/}
// ç°åœ¨ä½¿ç”¨ HOC
const EnhancedComponent = enhance(WrappedComponent);

// å¢å¼ºç»„ä»¶æ²¡æœ‰ staticMethod
typeof EnhancedComponent.staticMethod === 'undefined' // true
```

ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä½ å¯ä»¥åœ¨è¿”å›ä¹‹å‰æŠŠè¿™äº›æ–¹æ³•æ‹·è´åˆ°å®¹å™¨ç»„ä»¶ä¸Šï¼š

```tsx
function enhance(WrappedComponent) {
  class Enhance extends React.Component {/*...*/}
  // å¿…é¡»å‡†ç¡®çŸ¥é“åº”è¯¥æ‹·è´å“ªäº›æ–¹æ³• :(
  Enhance.staticMethod = WrappedComponent.staticMethod;
  return Enhance;
}
```

ä½†è¦è¿™æ ·åšï¼Œä½ éœ€è¦çŸ¥é“å“ªäº›æ–¹æ³•åº”è¯¥è¢«æ‹·è´ã€‚ä½ å¯ä»¥ä½¿ç”¨Â [hoist-non-react-statics](https://github.com/mridgway/hoist-non-react-statics)Â è‡ªåŠ¨æ‹·è´æ‰€æœ‰é React é™æ€æ–¹æ³•:

```tsx
import hoistNonReactStatic from 'hoist-non-react-statics';
function enhance(WrappedComponent) {
  class Enhance extends React.Component {/*...*/}
  hoistNonReactStatic(Enhance, WrappedComponent);
  return Enhance;
}
```

```ad-tip
**With implicit typing (Best Solution)**

The following shows an apporach where you don't have to type your static properties explicitly. I personally prefer this over any other solution, since it is the shortest and most clean way.

~~~javascript
const PanelComponent: React.FC<Props> = (props) => {
 ...
}

export const Panel = Object.assign(PanelComponent, { PanelFieldset })
~~~

**With explicit typing (Previous Solution)**

If you want to type your static properties explicitly, extending @Andrew's answer, usingÂ `typeof PanelFieldset`Â should be more convenient to type your component.

~~~```~~~javascript
type IPanel<P> = React.FunctionComponent<P> & {
  Fieldset: typeof PanelFieldset; // add this
}

const Panel: IPanel<Props> = (props) => {
}

Panel.Fieldset = PanelFieldset;
```
```

# å‚è€ƒ
- [é«˜é˜¶ç»„ä»¶ â€“ React](https://zh-hans.reactjs.org/docs/higher-order-components.html)
